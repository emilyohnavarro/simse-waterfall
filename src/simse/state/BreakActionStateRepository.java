/* File generated by: simse.codegenerator.stategenerator.RepositoryGenerator */
package simse.state;

import simse.adts.objects.*;
import simse.adts.actions.*;
import java.util.*;

public class BreakActionStateRepository implements Cloneable {
	private Vector<BreakAction> actions;

	public BreakActionStateRepository() {
		actions = new Vector<BreakAction>();
	}

	public Object clone() {
		try {
			BreakActionStateRepository cl = (BreakActionStateRepository) (super
					.clone());
			Vector<BreakAction> clonedActions = new Vector<BreakAction>();
			for (int i = 0; i < actions.size(); i++) {
				clonedActions.add((BreakAction) actions.elementAt(i).clone());
			}
			cl.actions = clonedActions;
			return cl;
		} catch (CloneNotSupportedException c) {
			System.out.println(c.getMessage());
		}
		return null;
	}

	public boolean add(BreakAction a) {
		if (actions.contains(a) == false) {
			actions.add(a);
			return true;
		}
		return false;
	}

	public boolean remove(BreakAction a) {
		if (actions.contains(a)) {
			actions.remove(a);
			return true;
		}
		return false;
	}

	public Vector<BreakAction> getAllActions() {
		return actions;
	}

	public Vector<BreakAction> getAllActions(SSObject a) {
		Vector<BreakAction> all = new Vector<BreakAction>();
		for (int i = 0; i < actions.size(); i++) {
			BreakAction b = actions.elementAt(i);
			Vector<SSObject> parts = b.getAllParticipants();
			for (int j = 0; j < parts.size(); j++) {
				if (parts.elementAt(j).equals(a)) {
					all.add(b);
					break;
				}
			}
		}
		return all;
	}

	public Vector<BreakAction> getAllActiveActions(SSObject a) {
		Vector<BreakAction> all = new Vector<BreakAction>();
		for (int i = 0; i < actions.size(); i++) {
			BreakAction b = actions.elementAt(i);
			Vector<SSObject> parts = b.getAllActiveParticipants();
			for (int j = 0; j < parts.size(); j++) {
				if (parts.elementAt(j).equals(a)) {
					all.add(b);
					break;
				}
			}
		}
		return all;
	}

	public Vector<BreakAction> getAllInactiveActions(SSObject a) {
		Vector<BreakAction> all = new Vector<BreakAction>();
		for (int i = 0; i < actions.size(); i++) {
			BreakAction b = actions.elementAt(i);
			Vector<SSObject> parts = b.getAllInactiveParticipants();
			for (int j = 0; j < parts.size(); j++) {
				if (parts.elementAt(j).equals(a)) {
					all.add(b);
					break;
				}
			}
		}
		return all;
	}

	public BreakAction getActionWithId(int id) {
		for (int i = 0; i < actions.size(); i++) {
			BreakAction act = actions.get(i);
			if (act.getId() == id) {
				return act;
			}
		}
		return null;
	}

	/*
	 * Replaces all the participants in each action with their equivalent
	 * objects in the current state. Calling this function solves the problem
	 * that happens when you clone actions -- their hashtables point to
	 * participant objects that were part of the previous, non-cloned state.
	 * Hence, this function should be called after this object is cloned.
	 */
	public void refetchParticipants(ArtifactStateRepository artifactRep,
			CustomerStateRepository customerRep,
			EmployeeStateRepository employeeRep,
			ProjectStateRepository projectRep, ToolStateRepository toolRep) {
		for (int i = 0; i < actions.size(); i++) {
			BreakAction act = actions.elementAt(i);
			act.refetchParticipants(artifactRep, customerRep, employeeRep,
					projectRep, toolRep);
		}
	}
}