/* File generated by: simse.codegenerator.stategenerator.ADTGenerator */
package simse.adts.actions;

import simse.adts.objects.*;
import simse.state.ArtifactStateRepository;
import simse.state.CustomerStateRepository;
import simse.state.EmployeeStateRepository;
import simse.state.ProjectStateRepository;
import simse.state.ToolStateRepository;
import java.util.*;

public class IntroduceNewRequirementsAction extends Action implements Cloneable {
	private Hashtable<Customer, Boolean> custs;
	private Hashtable<Artifact, Boolean> associatedrequirementsdocuments;
	private Hashtable<Project, Boolean> projs;
	private Hashtable<Employee, Boolean> empwoverheadtexts;
	private Hashtable<Artifact, Boolean> associatedcodes;
	private Hashtable<Artifact, Boolean> associateddesigndocuments;
	private Hashtable<Artifact, Boolean> associatedsystemtestplans;
	private int timeToLive;

	public IntroduceNewRequirementsAction() {
		custs = new Hashtable<Customer, Boolean>();
		associatedrequirementsdocuments = new Hashtable<Artifact, Boolean>();
		projs = new Hashtable<Project, Boolean>();
		empwoverheadtexts = new Hashtable<Employee, Boolean>();
		associatedcodes = new Hashtable<Artifact, Boolean>();
		associateddesigndocuments = new Hashtable<Artifact, Boolean>();
		associatedsystemtestplans = new Hashtable<Artifact, Boolean>();
		timeToLive = 1;
	}

	public Object clone() {
		IntroduceNewRequirementsAction cl = (IntroduceNewRequirementsAction) (super
				.clone());
		Hashtable<Customer, Boolean> clonedcusts = new Hashtable<Customer, Boolean>();
		clonedcusts.putAll(custs);
		cl.custs = clonedcusts;
		Hashtable<Artifact, Boolean> clonedassociatedrequirementsdocuments = new Hashtable<Artifact, Boolean>();
		clonedassociatedrequirementsdocuments
				.putAll(associatedrequirementsdocuments);
		cl.associatedrequirementsdocuments = clonedassociatedrequirementsdocuments;
		Hashtable<Project, Boolean> clonedprojs = new Hashtable<Project, Boolean>();
		clonedprojs.putAll(projs);
		cl.projs = clonedprojs;
		Hashtable<Employee, Boolean> clonedempwoverheadtexts = new Hashtable<Employee, Boolean>();
		clonedempwoverheadtexts.putAll(empwoverheadtexts);
		cl.empwoverheadtexts = clonedempwoverheadtexts;
		Hashtable<Artifact, Boolean> clonedassociatedcodes = new Hashtable<Artifact, Boolean>();
		clonedassociatedcodes.putAll(associatedcodes);
		cl.associatedcodes = clonedassociatedcodes;
		Hashtable<Artifact, Boolean> clonedassociateddesigndocuments = new Hashtable<Artifact, Boolean>();
		clonedassociateddesigndocuments.putAll(associateddesigndocuments);
		cl.associateddesigndocuments = clonedassociateddesigndocuments;
		Hashtable<Artifact, Boolean> clonedassociatedsystemtestplans = new Hashtable<Artifact, Boolean>();
		clonedassociatedsystemtestplans.putAll(associatedsystemtestplans);
		cl.associatedsystemtestplans = clonedassociatedsystemtestplans;
		return cl;
	}

	public int getTimeToLive() {
		return timeToLive;
	}

	public void decrementTimeToLive() {
		timeToLive--;
		if (timeToLive < 0) {
			timeToLive = 0;
		}
	}

	public Vector<SSObject> getAllParticipants() {
		Vector<SSObject> all = new Vector<SSObject>();
		all.addAll(getAllCusts());
		all.addAll(getAllAssociatedRequirementsDocuments());
		all.addAll(getAllProjs());
		all.addAll(getAllEmpWOverheadTexts());
		all.addAll(getAllAssociatedCodes());
		all.addAll(getAllAssociatedDesignDocuments());
		all.addAll(getAllAssociatedSystemTestPlans());
		return all;
	}

	public Vector<SSObject> getAllActiveParticipants() {
		Vector<SSObject> all = new Vector<SSObject>();
		all.addAll(getAllActiveCusts());
		all.addAll(getAllActiveAssociatedRequirementsDocuments());
		all.addAll(getAllActiveProjs());
		all.addAll(getAllActiveEmpWOverheadTexts());
		all.addAll(getAllActiveAssociatedCodes());
		all.addAll(getAllActiveAssociatedDesignDocuments());
		all.addAll(getAllActiveAssociatedSystemTestPlans());
		return all;
	}

	public Vector<SSObject> getAllInactiveParticipants() {
		Vector<SSObject> all = new Vector<SSObject>();
		all.addAll(getAllInactiveCusts());
		all.addAll(getAllInactiveAssociatedRequirementsDocuments());
		all.addAll(getAllInactiveProjs());
		all.addAll(getAllInactiveEmpWOverheadTexts());
		all.addAll(getAllInactiveAssociatedCodes());
		all.addAll(getAllInactiveAssociatedDesignDocuments());
		all.addAll(getAllInactiveAssociatedSystemTestPlans());
		return all;
	}

	public Vector<Customer> getAllCusts() {
		Vector<Customer> a = new Vector<Customer>();
		Enumeration<Customer> e = custs.keys();
		for (int i = 0; i < custs.size(); i++) {
			a.add(e.nextElement());
		}
		return a;
	}

	public Vector<Customer> getAllActiveCusts() {
		Vector<Customer> a = new Vector<Customer>();
		Enumeration<Customer> e = custs.keys();
		for (int i = 0; i < custs.size(); i++) {
			Customer key = e.nextElement();
			if ((custs.get(key)).booleanValue() == true) {
				a.add(key);
			}
		}
		return a;
	}

	public Vector<Customer> getAllInactiveCusts() {
		Vector<Customer> a = new Vector<Customer>();
		Enumeration<Customer> e = custs.keys();
		for (int i = 0; i < custs.size(); i++) {
			Customer key = e.nextElement();
			if ((custs.get(key)).booleanValue() == false) {
				a.add(key);
			}
		}
		return a;
	}

	public boolean addCust(Customer a) {
		if ((custs.containsKey(a)) || (((a instanceof ACustomer) == false))
				|| (custs.size() >= 1)) {
			return false;
		} else {
			custs.put(a, new Boolean(true));
			return true;
		}
	}

	public boolean removeCust(Customer a) {
		if (custs.containsKey(a)) {
			custs.remove(a);
			return true;
		}
		return false;
	}

	public boolean setCustActive(Customer a) {
		if (custs.containsKey(a)) {
			custs.put(a, new Boolean(true));
			return true;
		}
		return false;
	}

	public boolean setCustInactive(Customer a) {
		if (custs.containsKey(a)) {
			custs.put(a, new Boolean(false));
			return true;
		}
		return false;
	}

	public Vector<Artifact> getAllAssociatedRequirementsDocuments() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associatedrequirementsdocuments.keys();
		for (int i = 0; i < associatedrequirementsdocuments.size(); i++) {
			a.add(e.nextElement());
		}
		return a;
	}

	public Vector<Artifact> getAllActiveAssociatedRequirementsDocuments() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associatedrequirementsdocuments.keys();
		for (int i = 0; i < associatedrequirementsdocuments.size(); i++) {
			Artifact key = e.nextElement();
			if ((associatedrequirementsdocuments.get(key)).booleanValue() == true) {
				a.add(key);
			}
		}
		return a;
	}

	public Vector<Artifact> getAllInactiveAssociatedRequirementsDocuments() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associatedrequirementsdocuments.keys();
		for (int i = 0; i < associatedrequirementsdocuments.size(); i++) {
			Artifact key = e.nextElement();
			if ((associatedrequirementsdocuments.get(key)).booleanValue() == false) {
				a.add(key);
			}
		}
		return a;
	}

	public boolean addAssociatedRequirementsDocument(Artifact a) {
		if ((associatedrequirementsdocuments.containsKey(a))
				|| (((a instanceof RequirementsDocument) == false))
				|| (associatedrequirementsdocuments.size() >= 1)) {
			return false;
		} else {
			associatedrequirementsdocuments.put(a, new Boolean(true));
			return true;
		}
	}

	public boolean removeAssociatedRequirementsDocument(Artifact a) {
		if (associatedrequirementsdocuments.containsKey(a)) {
			associatedrequirementsdocuments.remove(a);
			return true;
		}
		return false;
	}

	public boolean setAssociatedRequirementsDocumentActive(Artifact a) {
		if (associatedrequirementsdocuments.containsKey(a)) {
			associatedrequirementsdocuments.put(a, new Boolean(true));
			return true;
		}
		return false;
	}

	public boolean setAssociatedRequirementsDocumentInactive(Artifact a) {
		if (associatedrequirementsdocuments.containsKey(a)) {
			associatedrequirementsdocuments.put(a, new Boolean(false));
			return true;
		}
		return false;
	}

	public Vector<Project> getAllProjs() {
		Vector<Project> a = new Vector<Project>();
		Enumeration<Project> e = projs.keys();
		for (int i = 0; i < projs.size(); i++) {
			a.add(e.nextElement());
		}
		return a;
	}

	public Vector<Project> getAllActiveProjs() {
		Vector<Project> a = new Vector<Project>();
		Enumeration<Project> e = projs.keys();
		for (int i = 0; i < projs.size(); i++) {
			Project key = e.nextElement();
			if ((projs.get(key)).booleanValue() == true) {
				a.add(key);
			}
		}
		return a;
	}

	public Vector<Project> getAllInactiveProjs() {
		Vector<Project> a = new Vector<Project>();
		Enumeration<Project> e = projs.keys();
		for (int i = 0; i < projs.size(); i++) {
			Project key = e.nextElement();
			if ((projs.get(key)).booleanValue() == false) {
				a.add(key);
			}
		}
		return a;
	}

	public boolean addProj(Project a) {
		if ((projs.containsKey(a)) || (((a instanceof SEProject) == false))
				|| (projs.size() >= 1)) {
			return false;
		} else {
			projs.put(a, new Boolean(true));
			return true;
		}
	}

	public boolean removeProj(Project a) {
		if (projs.containsKey(a)) {
			projs.remove(a);
			return true;
		}
		return false;
	}

	public boolean setProjActive(Project a) {
		if (projs.containsKey(a)) {
			projs.put(a, new Boolean(true));
			return true;
		}
		return false;
	}

	public boolean setProjInactive(Project a) {
		if (projs.containsKey(a)) {
			projs.put(a, new Boolean(false));
			return true;
		}
		return false;
	}

	public Vector<Employee> getAllEmpWOverheadTexts() {
		Vector<Employee> a = new Vector<Employee>();
		Enumeration<Employee> e = empwoverheadtexts.keys();
		for (int i = 0; i < empwoverheadtexts.size(); i++) {
			a.add(e.nextElement());
		}
		return a;
	}

	public Vector<Employee> getAllActiveEmpWOverheadTexts() {
		Vector<Employee> a = new Vector<Employee>();
		Enumeration<Employee> e = empwoverheadtexts.keys();
		for (int i = 0; i < empwoverheadtexts.size(); i++) {
			Employee key = e.nextElement();
			if ((empwoverheadtexts.get(key)).booleanValue() == true) {
				a.add(key);
			}
		}
		return a;
	}

	public Vector<Employee> getAllInactiveEmpWOverheadTexts() {
		Vector<Employee> a = new Vector<Employee>();
		Enumeration<Employee> e = empwoverheadtexts.keys();
		for (int i = 0; i < empwoverheadtexts.size(); i++) {
			Employee key = e.nextElement();
			if ((empwoverheadtexts.get(key)).booleanValue() == false) {
				a.add(key);
			}
		}
		return a;
	}

	public boolean addEmpWOverheadText(Employee a) {
		if ((empwoverheadtexts.containsKey(a))
				|| (((a instanceof SoftwareEngineer) == false))) {
			return false;
		} else {
			empwoverheadtexts.put(a, new Boolean(true));
			return true;
		}
	}

	public boolean removeEmpWOverheadText(Employee a) {
		if (empwoverheadtexts.containsKey(a)) {
			empwoverheadtexts.remove(a);
			return true;
		}
		return false;
	}

	public boolean setEmpWOverheadTextActive(Employee a) {
		if (empwoverheadtexts.containsKey(a)) {
			empwoverheadtexts.put(a, new Boolean(true));
			return true;
		}
		return false;
	}

	public boolean setEmpWOverheadTextInactive(Employee a) {
		if (empwoverheadtexts.containsKey(a)) {
			empwoverheadtexts.put(a, new Boolean(false));
			return true;
		}
		return false;
	}

	public Vector<Artifact> getAllAssociatedCodes() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associatedcodes.keys();
		for (int i = 0; i < associatedcodes.size(); i++) {
			a.add(e.nextElement());
		}
		return a;
	}

	public Vector<Artifact> getAllActiveAssociatedCodes() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associatedcodes.keys();
		for (int i = 0; i < associatedcodes.size(); i++) {
			Artifact key = e.nextElement();
			if ((associatedcodes.get(key)).booleanValue() == true) {
				a.add(key);
			}
		}
		return a;
	}

	public Vector<Artifact> getAllInactiveAssociatedCodes() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associatedcodes.keys();
		for (int i = 0; i < associatedcodes.size(); i++) {
			Artifact key = e.nextElement();
			if ((associatedcodes.get(key)).booleanValue() == false) {
				a.add(key);
			}
		}
		return a;
	}

	public boolean addAssociatedCode(Artifact a) {
		if ((associatedcodes.containsKey(a))
				|| (((a instanceof Code) == false))
				|| (associatedcodes.size() >= 1)) {
			return false;
		} else {
			associatedcodes.put(a, new Boolean(true));
			return true;
		}
	}

	public boolean removeAssociatedCode(Artifact a) {
		if (associatedcodes.containsKey(a)) {
			associatedcodes.remove(a);
			return true;
		}
		return false;
	}

	public boolean setAssociatedCodeActive(Artifact a) {
		if (associatedcodes.containsKey(a)) {
			associatedcodes.put(a, new Boolean(true));
			return true;
		}
		return false;
	}

	public boolean setAssociatedCodeInactive(Artifact a) {
		if (associatedcodes.containsKey(a)) {
			associatedcodes.put(a, new Boolean(false));
			return true;
		}
		return false;
	}

	public Vector<Artifact> getAllAssociatedDesignDocuments() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associateddesigndocuments.keys();
		for (int i = 0; i < associateddesigndocuments.size(); i++) {
			a.add(e.nextElement());
		}
		return a;
	}

	public Vector<Artifact> getAllActiveAssociatedDesignDocuments() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associateddesigndocuments.keys();
		for (int i = 0; i < associateddesigndocuments.size(); i++) {
			Artifact key = e.nextElement();
			if ((associateddesigndocuments.get(key)).booleanValue() == true) {
				a.add(key);
			}
		}
		return a;
	}

	public Vector<Artifact> getAllInactiveAssociatedDesignDocuments() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associateddesigndocuments.keys();
		for (int i = 0; i < associateddesigndocuments.size(); i++) {
			Artifact key = e.nextElement();
			if ((associateddesigndocuments.get(key)).booleanValue() == false) {
				a.add(key);
			}
		}
		return a;
	}

	public boolean addAssociatedDesignDocument(Artifact a) {
		if ((associateddesigndocuments.containsKey(a))
				|| (((a instanceof DesignDocument) == false))
				|| (associateddesigndocuments.size() >= 1)) {
			return false;
		} else {
			associateddesigndocuments.put(a, new Boolean(true));
			return true;
		}
	}

	public boolean removeAssociatedDesignDocument(Artifact a) {
		if (associateddesigndocuments.containsKey(a)) {
			associateddesigndocuments.remove(a);
			return true;
		}
		return false;
	}

	public boolean setAssociatedDesignDocumentActive(Artifact a) {
		if (associateddesigndocuments.containsKey(a)) {
			associateddesigndocuments.put(a, new Boolean(true));
			return true;
		}
		return false;
	}

	public boolean setAssociatedDesignDocumentInactive(Artifact a) {
		if (associateddesigndocuments.containsKey(a)) {
			associateddesigndocuments.put(a, new Boolean(false));
			return true;
		}
		return false;
	}

	public Vector<Artifact> getAllAssociatedSystemTestPlans() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associatedsystemtestplans.keys();
		for (int i = 0; i < associatedsystemtestplans.size(); i++) {
			a.add(e.nextElement());
		}
		return a;
	}

	public Vector<Artifact> getAllActiveAssociatedSystemTestPlans() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associatedsystemtestplans.keys();
		for (int i = 0; i < associatedsystemtestplans.size(); i++) {
			Artifact key = e.nextElement();
			if ((associatedsystemtestplans.get(key)).booleanValue() == true) {
				a.add(key);
			}
		}
		return a;
	}

	public Vector<Artifact> getAllInactiveAssociatedSystemTestPlans() {
		Vector<Artifact> a = new Vector<Artifact>();
		Enumeration<Artifact> e = associatedsystemtestplans.keys();
		for (int i = 0; i < associatedsystemtestplans.size(); i++) {
			Artifact key = e.nextElement();
			if ((associatedsystemtestplans.get(key)).booleanValue() == false) {
				a.add(key);
			}
		}
		return a;
	}

	public boolean addAssociatedSystemTestPlan(Artifact a) {
		if ((associatedsystemtestplans.containsKey(a))
				|| (((a instanceof SystemTestPlan) == false))
				|| (associatedsystemtestplans.size() >= 1)) {
			return false;
		} else {
			associatedsystemtestplans.put(a, new Boolean(true));
			return true;
		}
	}

	public boolean removeAssociatedSystemTestPlan(Artifact a) {
		if (associatedsystemtestplans.containsKey(a)) {
			associatedsystemtestplans.remove(a);
			return true;
		}
		return false;
	}

	public boolean setAssociatedSystemTestPlanActive(Artifact a) {
		if (associatedsystemtestplans.containsKey(a)) {
			associatedsystemtestplans.put(a, new Boolean(true));
			return true;
		}
		return false;
	}

	public boolean setAssociatedSystemTestPlanInactive(Artifact a) {
		if (associatedsystemtestplans.containsKey(a)) {
			associatedsystemtestplans.put(a, new Boolean(false));
			return true;
		}
		return false;
	}

	/*
	 * Replaces all the participants in this action with their equivalent
	 * objects in the current state. Calling this function solves the problem
	 * that happens when you clone actions -- their hashtables point to
	 * participant objects that were part of the previous, non-cloned state.
	 * Hence, this function should be called after this object is cloned.
	 */
	public void refetchParticipants(ArtifactStateRepository artifactRep,
			CustomerStateRepository customerRep,
			EmployeeStateRepository employeeRep,
			ProjectStateRepository projectRep, ToolStateRepository toolRep) {
		// cust participants:
		Hashtable<Customer, Boolean> newCusts = new Hashtable<Customer, Boolean>();
		Iterator<Map.Entry<Customer, Boolean>> custsIterator = custs.entrySet()
				.iterator();
		while (custsIterator.hasNext()) {
			Map.Entry<Customer, Boolean> entry = custsIterator.next();
			Customer oldCust = entry.getKey();
			if (oldCust instanceof ACustomer) {
				Customer newCust = customerRep.getACustomerStateRepository()
						.get(((ACustomer) oldCust).getName());
				Boolean activeStatus = custs.get(oldCust);
				newCusts.put(newCust, activeStatus);
			}
		}
		custs.clear();
		custs.putAll(newCusts);

		// associatedrequirementsdocument participants:
		Hashtable<Artifact, Boolean> newAssociatedRequirementsDocuments = new Hashtable<Artifact, Boolean>();
		Iterator<Map.Entry<Artifact, Boolean>> associatedrequirementsdocumentsIterator = associatedrequirementsdocuments
				.entrySet().iterator();
		while (associatedrequirementsdocumentsIterator.hasNext()) {
			Map.Entry<Artifact, Boolean> entry = associatedrequirementsdocumentsIterator
					.next();
			Artifact oldAssociatedRequirementsDocument = entry.getKey();
			if (oldAssociatedRequirementsDocument instanceof RequirementsDocument) {
				Artifact newAssociatedRequirementsDocument = artifactRep
						.getRequirementsDocumentStateRepository()
						.get(((RequirementsDocument) oldAssociatedRequirementsDocument)
								.getName());
				Boolean activeStatus = associatedrequirementsdocuments
						.get(oldAssociatedRequirementsDocument);
				newAssociatedRequirementsDocuments.put(
						newAssociatedRequirementsDocument, activeStatus);
			}
		}
		associatedrequirementsdocuments.clear();
		associatedrequirementsdocuments
				.putAll(newAssociatedRequirementsDocuments);

		// proj participants:
		Hashtable<Project, Boolean> newProjs = new Hashtable<Project, Boolean>();
		Iterator<Map.Entry<Project, Boolean>> projsIterator = projs.entrySet()
				.iterator();
		while (projsIterator.hasNext()) {
			Map.Entry<Project, Boolean> entry = projsIterator.next();
			Project oldProj = entry.getKey();
			if (oldProj instanceof SEProject) {
				Project newProj = projectRep.getSEProjectStateRepository().get(
						((SEProject) oldProj).getDescription());
				Boolean activeStatus = projs.get(oldProj);
				newProjs.put(newProj, activeStatus);
			}
		}
		projs.clear();
		projs.putAll(newProjs);

		// empwoverheadtext participants:
		Hashtable<Employee, Boolean> newEmpWOverheadTexts = new Hashtable<Employee, Boolean>();
		Iterator<Map.Entry<Employee, Boolean>> empwoverheadtextsIterator = empwoverheadtexts
				.entrySet().iterator();
		while (empwoverheadtextsIterator.hasNext()) {
			Map.Entry<Employee, Boolean> entry = empwoverheadtextsIterator
					.next();
			Employee oldEmpWOverheadText = entry.getKey();
			if (oldEmpWOverheadText instanceof SoftwareEngineer) {
				Employee newEmpWOverheadText = employeeRep
						.getSoftwareEngineerStateRepository().get(
								((SoftwareEngineer) oldEmpWOverheadText)
										.getName());
				Boolean activeStatus = empwoverheadtexts
						.get(oldEmpWOverheadText);
				newEmpWOverheadTexts.put(newEmpWOverheadText, activeStatus);
			}
		}
		empwoverheadtexts.clear();
		empwoverheadtexts.putAll(newEmpWOverheadTexts);

		// associatedcode participants:
		Hashtable<Artifact, Boolean> newAssociatedCodes = new Hashtable<Artifact, Boolean>();
		Iterator<Map.Entry<Artifact, Boolean>> associatedcodesIterator = associatedcodes
				.entrySet().iterator();
		while (associatedcodesIterator.hasNext()) {
			Map.Entry<Artifact, Boolean> entry = associatedcodesIterator.next();
			Artifact oldAssociatedCode = entry.getKey();
			if (oldAssociatedCode instanceof Code) {
				Artifact newAssociatedCode = artifactRep
						.getCodeStateRepository().get(
								((Code) oldAssociatedCode).getName());
				Boolean activeStatus = associatedcodes.get(oldAssociatedCode);
				newAssociatedCodes.put(newAssociatedCode, activeStatus);
			}
		}
		associatedcodes.clear();
		associatedcodes.putAll(newAssociatedCodes);

		// associateddesigndocument participants:
		Hashtable<Artifact, Boolean> newAssociatedDesignDocuments = new Hashtable<Artifact, Boolean>();
		Iterator<Map.Entry<Artifact, Boolean>> associateddesigndocumentsIterator = associateddesigndocuments
				.entrySet().iterator();
		while (associateddesigndocumentsIterator.hasNext()) {
			Map.Entry<Artifact, Boolean> entry = associateddesigndocumentsIterator
					.next();
			Artifact oldAssociatedDesignDocument = entry.getKey();
			if (oldAssociatedDesignDocument instanceof DesignDocument) {
				Artifact newAssociatedDesignDocument = artifactRep
						.getDesignDocumentStateRepository().get(
								((DesignDocument) oldAssociatedDesignDocument)
										.getName());
				Boolean activeStatus = associateddesigndocuments
						.get(oldAssociatedDesignDocument);
				newAssociatedDesignDocuments.put(newAssociatedDesignDocument,
						activeStatus);
			}
		}
		associateddesigndocuments.clear();
		associateddesigndocuments.putAll(newAssociatedDesignDocuments);

		// associatedsystemtestplan participants:
		Hashtable<Artifact, Boolean> newAssociatedSystemTestPlans = new Hashtable<Artifact, Boolean>();
		Iterator<Map.Entry<Artifact, Boolean>> associatedsystemtestplansIterator = associatedsystemtestplans
				.entrySet().iterator();
		while (associatedsystemtestplansIterator.hasNext()) {
			Map.Entry<Artifact, Boolean> entry = associatedsystemtestplansIterator
					.next();
			Artifact oldAssociatedSystemTestPlan = entry.getKey();
			if (oldAssociatedSystemTestPlan instanceof SystemTestPlan) {
				Artifact newAssociatedSystemTestPlan = artifactRep
						.getSystemTestPlanStateRepository().get(
								((SystemTestPlan) oldAssociatedSystemTestPlan)
										.getName());
				Boolean activeStatus = associatedsystemtestplans
						.get(oldAssociatedSystemTestPlan);
				newAssociatedSystemTestPlans.put(newAssociatedSystemTestPlan,
						activeStatus);
			}
		}
		associatedsystemtestplans.clear();
		associatedsystemtestplans.putAll(newAssociatedSystemTestPlans);

	}
}