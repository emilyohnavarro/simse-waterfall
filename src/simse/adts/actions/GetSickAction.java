/* File generated by: simse.codegenerator.stategenerator.ADTGenerator */
package simse.adts.actions;

import simse.adts.objects.*;
import simse.state.ArtifactStateRepository;
import simse.state.CustomerStateRepository;
import simse.state.EmployeeStateRepository;
import simse.state.ProjectStateRepository;
import simse.state.ToolStateRepository;
import java.util.*;

public class GetSickAction extends Action implements Cloneable {
	private Hashtable<Employee, Boolean> sickpersons;

	public GetSickAction() {
		sickpersons = new Hashtable<Employee, Boolean>();
	}

	public Object clone() {
		GetSickAction cl = (GetSickAction) (super.clone());
		Hashtable<Employee, Boolean> clonedsickpersons = new Hashtable<Employee, Boolean>();
		clonedsickpersons.putAll(sickpersons);
		cl.sickpersons = clonedsickpersons;
		return cl;
	}

	public Vector<SSObject> getAllParticipants() {
		Vector<SSObject> all = new Vector<SSObject>();
		all.addAll(getAllSickPersons());
		return all;
	}

	public Vector<SSObject> getAllActiveParticipants() {
		Vector<SSObject> all = new Vector<SSObject>();
		all.addAll(getAllActiveSickPersons());
		return all;
	}

	public Vector<SSObject> getAllInactiveParticipants() {
		Vector<SSObject> all = new Vector<SSObject>();
		all.addAll(getAllInactiveSickPersons());
		return all;
	}

	public Vector<Employee> getAllSickPersons() {
		Vector<Employee> a = new Vector<Employee>();
		Enumeration<Employee> e = sickpersons.keys();
		for (int i = 0; i < sickpersons.size(); i++) {
			a.add(e.nextElement());
		}
		return a;
	}

	public Vector<Employee> getAllActiveSickPersons() {
		Vector<Employee> a = new Vector<Employee>();
		Enumeration<Employee> e = sickpersons.keys();
		for (int i = 0; i < sickpersons.size(); i++) {
			Employee key = e.nextElement();
			if ((sickpersons.get(key)).booleanValue() == true) {
				a.add(key);
			}
		}
		return a;
	}

	public Vector<Employee> getAllInactiveSickPersons() {
		Vector<Employee> a = new Vector<Employee>();
		Enumeration<Employee> e = sickpersons.keys();
		for (int i = 0; i < sickpersons.size(); i++) {
			Employee key = e.nextElement();
			if ((sickpersons.get(key)).booleanValue() == false) {
				a.add(key);
			}
		}
		return a;
	}

	public boolean addSickPerson(Employee a) {
		if ((sickpersons.containsKey(a))
				|| (((a instanceof SoftwareEngineer) == false))
				|| (sickpersons.size() >= 1)) {
			return false;
		} else {
			sickpersons.put(a, new Boolean(true));
			return true;
		}
	}

	public boolean removeSickPerson(Employee a) {
		if (sickpersons.containsKey(a)) {
			sickpersons.remove(a);
			return true;
		}
		return false;
	}

	public boolean setSickPersonActive(Employee a) {
		if (sickpersons.containsKey(a)) {
			sickpersons.put(a, new Boolean(true));
			return true;
		}
		return false;
	}

	public boolean setSickPersonInactive(Employee a) {
		if (sickpersons.containsKey(a)) {
			sickpersons.put(a, new Boolean(false));
			return true;
		}
		return false;
	}

	/*
	 * Replaces all the participants in this action with their equivalent
	 * objects in the current state. Calling this function solves the problem
	 * that happens when you clone actions -- their hashtables point to
	 * participant objects that were part of the previous, non-cloned state.
	 * Hence, this function should be called after this object is cloned.
	 */
	public void refetchParticipants(ArtifactStateRepository artifactRep,
			CustomerStateRepository customerRep,
			EmployeeStateRepository employeeRep,
			ProjectStateRepository projectRep, ToolStateRepository toolRep) {
		// sickperson participants:
		Hashtable<Employee, Boolean> newSickPersons = new Hashtable<Employee, Boolean>();
		Iterator<Map.Entry<Employee, Boolean>> sickpersonsIterator = sickpersons
				.entrySet().iterator();
		while (sickpersonsIterator.hasNext()) {
			Map.Entry<Employee, Boolean> entry = sickpersonsIterator.next();
			Employee oldSickPerson = entry.getKey();
			if (oldSickPerson instanceof SoftwareEngineer) {
				Employee newSickPerson = employeeRep
						.getSoftwareEngineerStateRepository().get(
								((SoftwareEngineer) oldSickPerson).getName());
				Boolean activeStatus = sickpersons.get(oldSickPerson);
				newSickPersons.put(newSickPerson, activeStatus);
			}
		}
		sickpersons.clear();
		sickpersons.putAll(newSickPersons);

	}
}